\input{chapter-header.tex}
% ===========================================================================
\chapter{Background}
\chaplabel{background}
\minitoc
% ===========================================================================
\introduction
% ===========================================================================
In this chapter we present the related work to this dissertation.
We first present a quick overview of language-side reflection followed by a description how reflection developed for \VMs.

In the context of this thesis we are mainly interested in behavioral reflection that requires strong support from the underlying \VM.
We identify that this form of reflection is rather costly, namely due to its late binding that does not allow for static optimizations.
Following to this, we present how different techniques of partial behavior reflection are used to limit the cost of reflection.
We see that reflection can be more efficient with more \VM support available.
At this point we outline the evolution of reflection in high-level languages with an ultimate goal being a language that has full control over its own \VM and thus blurring the line between language-side and \VM-side.

The second part of this background chapter focuses on different kinds of \VMs and how they are built.
We find that metacircular \VMs provide a good match to our idea of unified language runtime. 
After presenting several recent metacircular \VM projects we conclude that most of them limit reflection at the \VM-level to compile time.
Only a couple of research \VMs have a uniform model that spans across all abstraction levels.
Among them is \P a research \ST \VM we contributed to previous to working on this dissertation.

This chapter finishes by presenting a detailed description of the problem statement and a final outlook of the upcoming chapters in the light of the found problems.
	
	
% ===========================================================================
\newpage
\section{Reflection}
% ===========================================================================

I this section we give a quick overview of the core features of reflection.
A system is said to be reflective if it is capable to reason about itself.
Typically we distinguish two forms of reflective access: structural and behavioral \cite{Maes87a}.
Structural reflection is concerned with the static structure of a program, while behavioral reflection focuses on the dynamic part of a running program.
Orthogonally to the previous categorization we distinguish between introspection and intercession. 
For introspection we only access a reified concept, whereas for intercession we alter the reified representation.

\begin{description}
\item[Structural Reflection] means to access the static structure of a program.
A typical example is to get the class of an object at runtime.
\begin{stcode}{}
'abc' class.
\end{stcode}

\item[Behavioral Reflection] means to directly interact with the running program.
For instance this includes reflectively activating a method.
\begin{stcode}{}
#Dictionary asClass perform: #new
\end{stcode}
%
Another more complex example to dynamically switch the execution context and resend the current method with another receiver.
\begin{stcode}{}
thisContext restartWithNewReceiver: Object new 
\end{stcode}
\end{description}

\noindent There is not always a clear separation between the two types of reflection possible.
For instance it is possible to add new methods which requires structural reflection.
At the same we alter the future program execution which also implies that the action was behavior reflection.
Typically we see that behavioral reflection stops at the granularity of a method.
For instance in \PH by default it is not possible to directly alter execution on a sub-method level \cite{Denk06a}.

Additional to separating reflection upon the representation it accesses, we distinguish what actions are performed on the reified representations.
Both of the following properties can apply for structural and behavioral reflection.
%
\begin{description}
\item[Introspection] is the form of reflection that does not alter the reified 	representation.
And example of this is the previous code excerpt where we access the class of an object.
	
\item[Intercession] implies that the underlying representation is altered.
Going back to the previous example that would for instance mean to change the class of an existing object.
\begin{stcode}{}
MyClass adoptInstance: anObject.
\end{stcode}
\end{description}
%

\noindent Unless specified otherwise we refer by \emph{reflection} to dynamic behavior reflection, where it is possible to perform intercession, hence altering the behavior at runtime.

% ---------------------------------------------------------------------------
\subsection{Scoping Reflection: Partial Reflection}
% ---------------------------------------------------------------------------
Reflection brings great power to a programming language.
However, especially behavioral reflection is linked to a significant overhead.
For instance the previous example of the reified execution context in \ST requires restricts the optimizations at \VM-level.
And more general, most reification comes at great costs \cite{Male96a}.
Hence already from a performance point of view it is natural to limit the scope of reflective behavior.
Even so structural reflection can pose an overhead it does not directly influence the evaluation.
For instance, using wrapped methods to alter execution has a wide-spread effect on the system.
Thus, there is also a motivation to limit the effect on evaluation introduced by reflection.
We will now discuss several axes along which we can limit the use of reflection.
%
\begin{description}
\item[Time:] Of course the most obvious axis is time itself.
	In the context of \ST, behavioral reflection implies that the reflective properties are accessed or modified dynamically.
	By dynamically adding or removing the reflective code we have time-delimited reflection.
	
\item[Type:] Another natural delimiter for reflection is the type of an object.
	Again, this is rather natural in terms of \ST reflection since the natural base to modify behavior are the compiled methods.
	Hence it is possible to use use method wrappers only on one class (and it subclasses) by installed modified methods.

\item[Stack:] A second interesting limitation axis is the stack.
	An example of that is the concept of tower of interpreters.
	During the development of \P an intermediate version of the \ST interpreter featured this special execution scheme \cite{Verw10a}.
	It allows the programmer to switch the current interpreter.
	This way an expression is evaluated with altered semantics.
	The solution presented in \P does not globally replace the interpreter but only for the given expression. 
	Hence once the expression returns, the modifications and the implied overhead are gone.

\item[Reference:] Starting from the concept of a proxy object we find another possibility to limit reflection by reference.
	Arnaud et al. describe a modified \PH runtime where the concept of a reference is fully reified as a so called handles \cite{Arna13a}.
	Handles allow programmers to install new behavior and even state on a single reference, without influencing the rest of the system.
	\todo{proper example: revokable reference... extending proxies}
\end{description}
%

\noindent Tanter et. al. describe \textsc{Reflex} \cite{Tant03a} a partial behavioral reflection system on top of \Java.
We see similar limitation mechanisms for the applications of aspects \cite{Kicz01a}, which in a certain way resembles intercession.
However, typically the systems using aspects have to prepared statically upfront with little means to change them at runtime.
Aspects can be used to globally modify a system and introduced code snippets in defined points, for instance before each method invocation.
Though they share an interesting concepts of limiting the introduced overhead using a pointcuts.
These are conditionals that are dynamically before evaluating aspects.

Both \textsc{Reflex} and aspects require the underlying system to be prepared upfront.
Unanticipated behavioral reflection is not directly possible.
Typically it is only possible to enable or disable the reflective features that have been prepared upfront.
Röthlisberger et al. propose \Gepetto a system \cite{Roet07b} that enables true unanticipated behavioral reflection on top of \ST.
\Gepetto provides a high-level \API to install behavior reflection.
\cb{more needed?}

% ---------------------------------------------------------------------------
\subsection{\VM-level Reflection}
% ---------------------------------------------------------------------------
The basic reflective features have to be provided by the underlying meta-level.
For high-level languages this is the \VM.
For instance, simple cases involve giving access to the class of an object or the possibility to reflectively invoke a method at runtime.
\PH for instance is a more complex case, where the \VM has to provide access to the current execution context for introspection and even modification.
The latter one has a significant influence on the underlying \VM architecture preventing certain low-level optimization which would shadow the access to certain context information.
What we see is that the meta-level enables reflection but usually is not reflective by its own.

Following the \ST principle that everything is an object one might assume that this also includes the \VM as it is already highly involved in supporting reflection.
Typically the \VM is implemented in C or C++ which have no reflection.
However, the \JIT is common exception as it has to interact dynamically with the language-side.
For instance the \JIT has to be aware of classes and the methods within.
And in dynamic system like \PH it has to be made aware of language-side changes to properly update the generated native code.
What we see is that the \JIT accesses structural information from the language-side.
However, the language-side is not capable to accessing \VM-level information.
The closest \VM interaction point typically is the bytecode generated at language-side and handed over to the \VM for execution.
Yet, this provides only a crude one-way interaction \cite{Kell12a}.

For highly reflective and dynamic languages like \PH we see a certain mismatch.
While it is possible to virtually change and modify everything at language-side we are locked out of the \VM.
One argument in favor of that is that the underlying \VM provides security by isolation.
This is true for a more static language which restricts the reflective power.
However, this is clearly not the case in \PH or \ST.
Since arbitrary code changes are possible at language-side the boundary level of the \VM seems arbitrary.
Going one 	step back we can see a certain evolution in reflection which we would like to extend down to the \VM.
%
\begin{figure}[h]
	\centering
	\includegraphics[scale=1.1]{vm-reflection-evolution}
	\figlabel{vm-reflection-evolution}
	\caption[High-level Language Reflection Evolution]{Evolution of reflection in high-level language runtimes.}
\end{figure}
%
\cb{recheck that the properties fit to what I told everybody}
\begin{enumerate}[a)]
\item \textbf{Language-side without reflection:} A language in this category requires a virtual machine to run but has no reflective properties.
	This includes early-stage languages such as the original Pascal-P system.
	Typically languages without reflection also lack the underlying \VM and are compiled directly to native code.
	\cb{thus they are one meta-level short of performing reflection}
	
\item \textbf{Language-side with limited reflection:}
	The next step is to support only certain static reflection.
	This might include structural reflection whose required information can be prepared upfront during the compilation phase.
	Such a system has no support for unanticipated reflection as there is no support from the \VM to dynamically reify concepts.
	A \VM with a \JIT in this category can perform strong optimizations and take full advantage of the runtime information.
	\cb{GO fits here? \Java only partially?}
	
\item \textbf{Language-side extended reflection:}
	The third category of high-level language runtimes has extended reflection with strong support from the underlying \VM.
	We put \PH, \ST implementations or \Self in this category of languages.
	The \VM supports complex reification of otherwise non-accessible concepts such as the stack.
	At this stage the \VM-level optimizations are a balance between restricting the supported language or sacrificing speed.
	
\item \textbf{Language-side access to the \VM:}
	The \VM support for reflection is highly extended compared to the previous category.
	Instead of a hidden property, certain \VM-level concepts are made explicitly accessible to the running language.
	Up to some extent this is similar to language-side structural reflection as the \VM only supports only a restricted interface which is defined at compile-time.
	In this category the language can only read (introspect) \VM properties.
	\todo{MIST has a GC mop that fits in this category}
	To our best knowledge there are no existing language-runtimes that fall into this category.

\item \textbf{Language-side modification of the \VM:}
	The previous category allows the language-side to safely read \VM-level properties.
	If we follow the same path as the language-side evolution of reflection the next step is to allow for self-modification.
	Such a language-runtime has a dynamic interface to change certain properties of the \VM.
	However, the \VM is still not fully reflective in the sense that not all \VM concepts are reified.
	This essentially limits the language-side to simple interactions and changes to the \VM itself.
	At this point the \VM can no longer guarantee safety by isolating the language-side from all the low-level details.
	Again no systems are known to fit in this category.
	
\item \textbf{Self-aware \VM:}
	We classify in the last category dynamic language-runtimes that have no longer a clear separation of \VM and language-side.
	The same reflective properties equally apply to language-side and the \VM.
	The way to achieve this is by flattening out the intermediate \VM and let the language-side directly control everything.
	Currently there are several research \VMs which can be classified as self-aware \VMs: The \P \VM \cite{Verw12a} is partially self-aware but in control of the underlying execution and the \Klein \VM is fully reflective \cite{Unga05a}. 
\end{enumerate}

\noindent From this overview of reflective evolution of high-level languages we see that there is only little research about self-aware \VMs or reflective \VMs.
In general high-level languages are built with a clear distinction of the language-side and the \VM.
However, with further reflective capabilities of the language-side we see that such a separation is no longer a guarantee for security.
In fact many security aspects have to be addressed already at language-side \cite{??}.
This we want to focus in this thesis on the reflective aspects of the \VM.
In order to further compare reflection in languages we will now discuss the different \VM building approaches. 

% ===========================================================================
\section{Open \VMs}
\seclabel{background-open-vms}
% ===========================================================================

High-level language \VMs are inherent complex pieces of software.
They have to combine two rather extreme goals: abstraction and performance.
We have seen that the required abstraction for the running high-level language has a strong influence on the \VM design.
At the same time the hard performance requirement requires precise interaction with the underlying hardware.
This goes even so far that specialized hardware is conceived to match the performance requirements \cite{Clic05a}.

The early \VMs focused on interpreting an abstract instruction set (bytecodes).
The benefits are twofold.
On the one hand the bytecodes guarantee certain platform independence by abstracting away from the \CPU specific instruction set.
On the other hand bytecodes allow to encode complex operations into little space both serving the hard memory constraints of the hardware and simplifying the design of a compiler.
Obviously this abstraction gain comes at a cost and ever since the first \VMs were built research and industry strive to reduce the interpretation overhead.
An efficient way to improve performance is to use a just in time compiler (\JIT) that dynamically generates native code from the bytecode \cite{??}.
In this case the bytecode becomes an intermediate representation (\IR) for a bigger compiler infrastructure.
However, \JIT compilers are notoriously complex as they crosscut many \VM components.
At the same time they crosscut all abstraction layers; they have to access high-level information from the running bytecodes and manage native code at the same time.
Similar, albeit less low-level oriented complexity applies to the automatic memory management present in most high-level language \VMs.
Garbage Collectors (\GC) evolved from simple helpers to complex software artifacts that for instance support concurrent garbage collection \cite{Clic05a}.

The increased complexity of the \VMs lead to more novel approaches on how to build \VMs.
\VMs are still build for a big part in C or C++ for performance reasons.
However, there are more high-level approaches that try to simplify creating \VMs by using building blocks \cite{Geof10a}.
In the following sections we are shedding light on metacircular \VMs which are programmed in the same language they in the end support.

% ---------------------------------------------------------------------------
\subsection{Metacircular \VMs}
\seclabel{background-metacircular-vms}
% ---------------------------------------------------------------------------
The ever growing complexity of \VMs and the abstraction mismatch between the \VM definition language and the final interpreted language lead to a new movement that tried to reduce complexity.
Among the \VMs using higher-level languages or frameworks to reduce the development effort the metacircular building process stands out.
Unlike the classical \VM which is built in C and compiled to the a binary, a metacircular \VM is written in the same language that it provides in the end.
The following figure highlights the most evident differences between a classical and a metacircular approach.
%
\begin{figure}[h]
	\centering
	\vspace{1mm}
	\includegraphics[scale=1.1]{vm-metacircular-building-process}
	\vspace{-10mm}
%	\figlabel{vm-metacircular-building-process}
\end{figure}
%
\begin{description}
\item[Classical \VM Compilation] \hfill
	\begin{enumerate}[a), nolistsep]
		\item \VM sources typically written in C or C++
		\item Compilation of the \VM sources using a C or C++ compiler
		\item Final Binary
	\end{enumerate}

\item[Metacircular \VM Compilation] \hfill
	\begin{enumerate}[nolistsep]
		\item \VM sources written in a high-level language, the same as the final \VM supports
		\item Compilation of the \VM sources happens by evaluating the \VM sources, allowing for compile-time reflection
		\item New \VM' binary built using an existing version of the \VM
		\item The new \VM Binary can be used to compile again a new \VM''
	\end{enumerate}
\end{description}

\noindent Using the same language for developing the \VM has several advantages.
Usually the \VM is in great contrast to language-side libraries on the same platform.
This is due to the low-level nature of the \VM.
Using a high-level language certain implementation details can be hidden.
Furthermore the metacircular approach provides the \VM developer with the same tools as a language-side programmer.
Typically this leads to faster development.


Inside the metacircular \VM community we see different approaches with varying levels of abstractions and reuse.
When compared, we find differences in how metacircular \VMs build \VM components (\GC, \JIT) and how the bootstrap or compilation of the new \VM works.
We see metacircular \VMs that use the high-level language as an advanced macro systems.
In a sense an extended version of C++'s templates.
Other approaches use the full reflective power of the high-level runtime to simplify code.
And even more advanced system automatically provide the \VM developer with \GC or a \JIT compiler.
We will now elaborate in more detail how metacircular \VMs are constructed.


\paragraph{Language Property Synthesis}
In the classical C-based \VM approach all \VM components have to be explicitly build.
Each \VM is a one of a kind with custom interpreter and a specialized memory manager.
Using high-level \VM frameworks it is possible to provide the \VM developer with prefabricated components.
For instance it is possible to simply parametrize a premade \GC to reduce development effort.
Looking at the evolution of metacircular \VMs we see both approaches.
For instance early metacircular solutions like the \Squeak \VM \cite{Inga97a} work more like a high-level C macro system.
The high-level language is used to generate C code which is then further compiled to the final \VM binary.
\VM components are declared in a very explicit style, again not much different from C++.
Memory for \VM-level structures has to be managed in the same way as its C++ counterpart by explicitly allocating and freeing objects.
On the other side we have \VM frameworks like \PyPy for the \Python language that provide automatic \GC and \JIT support.
Here the developer writes a new \VM in almost the same way as a normal \Python program.
In the ideal case only certain hints are necessary to create a \JIT.

\todo{Truffle as extreme to that track: Interpreter implementation on \AST basis, not explicit bytecode interpreter (which would be typical in C)}

\paragraph{Bootstrap Process}
A crucial step during the development with the metacircular \VMs is the bootstrap of the new \VM.
We distinguish mainly between two approaches, indirect bootstrap and direct bootstrap.
%
\begin{figure}[h]
	\centering
	\vspace{2mm}
	\includegraphics[scale=1.1]{vm-metacircular-bootstrap}
	\caption{Metacircular \VM Bootstrap Types}
	\vspace{-5mm}
	\figlabel{background-metacircular-bootstrap}
\end{figure}
%
\begin{description}
	\item[Indirect Bootstrap:] Metacircular \VMs with an indirect bootstrap use an intermediate language to compile a new \VM binary.
	A typical example of this approach is \Squeak and \PyPy using C.
	Both of these system imply a complete C compilation stack.
	The advantage of this approach is the that C is heavily optimized thus reducing the development effort for the \VM framework.
	However, C already hides a lot of low-level details away.
	Typically the \VM framework has to work around these limitations when working directly with native code for instance in the \JIT.
	We have explicitly seen these limitations while working on the \P \VM.
	
	\item[Direct Bootstrap:] Metacircular \VMs with a direct bootstrap are directly in charge of generating the native code for the final binary.
	We have seen in \P that many C-level optimizations have only limited impact on the final speed.
	A major speedup is achieved by using a native stack and directly generating native code instead of using a bytecode interpreter.
	Hence the \VM will probably require an assembler framework which in return can be used for the direct bootstrap.
	This means that only limited additional efforts are necessary for a direct bootstrap.
	As a result the direct bootstrap allows full control of how the final binary will look like.
\end{description}

% ---------------------------------------------------------------------------
\subsection{Compile-time Reified \VMs}
% ---------------------------------------------------------------------------
After presented the technical background of metacircular \VMs we are presenting several concrete implementations in more detail.
In this first part present \VMs that focus on compile-time reflection.
In \secref{background-reified-vms} we will then focus on a list of \VMs that reify their components and allow for a more close interaction with the language-side.


\subsubsection*{\Squeak \ST \VM}
\seclabel{background-squeak}
% ---------------------------------------------------------------------------

One of the first metacircular \VMs presented is the \Squeak \VM\cite{Inga97a}.
Its core building system is still in active use for the \urlfootnote{\Cog \VM}{http://www.mirandabanda.org/cogblog/} which extends \Squeak with a \JIT.
The \Cog \VM is used as default by the \urlfootnote{\PH}{http://pharo.org/} programming language.
\Squeak is built around a \ST dialect called \Slang that is exported to C to be compiled to the final \VM binary.
Additionally the \Slang sources can be interpreted to provide an interactive simulator of the \VM, including full graphical support.

The \VM itself is mostly written in a dialect of \ST called \Slang that is essentially limited to the functionality that can be expressed with standard C code.
\Slang in this case is mostly a high-level C preprocessor.
Even though \Slang basically has the same syntax as \ST it is semantically constrained to expressions that can be resolved statically at compilation or code generation time and are compatible with C.
Hence \Slang's semantics are closer to C than to \ST.
Unlike later metacircular frameworks \Squeak uses little or no compile-time reflection to simplify the \VM designs.
However, class composition and traits help structuring the sources.
Next to the \Slang source which account for the biggest part of the interpreter code some \OS-related code and plugins are written in C.
To facilitate the interaction with the pure C part \Slang supports inline C expressions and type annotations.

A great achievement of the \Squeak \VM is a simulator environment that enables programmers to interact dynamically with the running \VM sources.
The simulator is capable or running a complete \Squeak \ST image including graphical user interface.
This means that programmers can change the sources of the running \VM and see the immediate effects in the simulator.
The simulator itself works by setting up a byte array which servers as native memory.
Then the \VM sources written in \Slang are interpreted by the \VM of the development environment.

We see that \Squeak is an early-stage metacircular \VM that uses an indirect bootstrap process.
Yet according to long-time \VM programmers the \Squeak infrastructure is more productive than a comparable C++ or pure C project.


% ---------------------------------------------------------------------------
\subsubsection*{\Jikes: High-level low-level Programming in with \MMTK}
\seclabel{background-jikes}
% ---------------------------------------------------------------------------
\Jikes (former \textsc{Jalapeño})is an early metacircular research \VM for \Java \cite{Alpe00a}.
The \Jikes \VM features several different garbage collectors and does not execute bytecodes but directly compiles to native code.

The \Jikes \VM had performance as a major goal, hence direct unobstructed interaction with the low-level world is necessary using a specialized framework.
High-level low-level programming \cite{Fram09a} is mentioned the first time in the context of the \Jikes \VM project.
The goal of high-level low-level programming is to the abstractions provided by high-level programming languages to simplify low-level programming specifically.
In the core this are the same motivations that drives the metacircular \VM community.

Frampton et al. present a low-level framework packaged as \ttt{org.vmmagic}, which is used as system interface for Jikes, an experimental Java VM.
Additionally their framework is successfully used in a separate project, the memory management toolkit (\MMTK) \cite{Blac04a} which is used independently in several other projects.
The \ttt{org.vmmagic} package introduces highly controlled low-level interaction in a statically type context.
In their framework, methods have to be annotated to enable the use of low-level functionality.

In a direct metacircular \VM building process (see \figref{background-metacircular-bootstrap}) it is inevitable to directly manage native-code.
Using a high-level low-level framework provides the necessary abstraction at this level.

% ---------------------------------------------------------------------------
\subsubsection*{\Maxine \Java \VM}
\seclabel{background-maxine}
% ---------------------------------------------------------------------------
\Maxine is a metacircular \Java \VM \cite{Wimm13a} focused on an efficient developer experience.
Typically \VM frameworks focus on abstraction at the code-level which should yield simpler code and thus help reducing development efforts.
However, in most situations the programmer is still forced to use existing unspecific tools for instance to debug the \VM.
In contrast to that, the \Maxine \VM provides first-hand tools to interact with the \VM in development.
\Maxine uses abstract and high-level representations of \VM-level concepts and consistently exposes them throughout the development process.
Inspectors at multiple abstraction levels are readily available while debugging, giving insights to the complete \VM state.
\Maxine provides and excellent navigation for generated native code by providing links back to language-side objects as well as other native code and symbols.

Even though the \Maxine projects follows an approach where reflection is only used at compile-time, the development tools themselves provide a live interaction with the running \VM artifact.
This means that when debugging the \VM it behaves almost like a life \ST image where a complete interaction with the underlying system is possible.
We identify this as crucial, as most of the time is spent debugging, notably on inadequate tools like \ttt{gdb} due to lack of alternatives.
Hence having a specific debuggers and inspectors greatly improve the interaction with the \VM artifact.

\subsubsection*{\PyPy Toolchain}
\seclabel{background-pypy}
% ---------------------------------------------------------------------------
\urlfootnote{\PyPy}{http://pypy.org/} is a \Python-based high-level \VM framework \cite{Rigo06a}.
\PyPy's major focus lies on an efficient metacircular \Python interpreter.
However, it has been successfully used to build \VMs for other languages including \ST \cite{Bolz08a}.
Interpreters are written in a type-inferable subset of \Python called \RPython.
The underlying \PyPy infrastructure implicitly provides memory management and \JIT compilation.

\paragraph{Provided \VM Features}
\PyPy follows a different approach from the previously presented \VM generation frameworks.
For instance, in Squeak and \Jikes the final \VM implementation is not much different from C or C++.
The programmer specifies all the components of the \VM explicitly, either by implementing them directly or using a provided library.
Compared to the more static C ans C++ these \VM generation frameworks make the compilation phase more tangible.
\ST in \Squeak or \Java in \Jikes or \Maxine fulfill the purpose of the template system in C++ or the restricted macro system in C.
For the explicit implementation part \PyPy is no different.
However, certain features for the final \VM are directly absorbed from the underlying \PyPy infrastructure.
For instance, the \JIT support or the \GC are not explicitly implemented but provided by the \PyPy framework itself.
This is a big difference to the other \VM frameworks as it allows programmers to write the \VM in a more high-level fashion.
For instance in \Squeak memory allocation, even for \VM-level objects, has to be handled in the same way as in C.
Whereas in \PyPy the garbage collection is left to the underlying infrastructure.

\paragraph{\RPython Interpretation}
At compile-time the interpretation stack for a newly implemented \VM on top of \PyPy looks as follows.
%
\begin{enumerate}
\item The final language runtime
\item The \VM written in \RPython
\item The \PyPy infrastructure (virtual compile-time \RPython interpreter)
\end{enumerate}
%
Unless in debug mode, the bottom-most layer is compiled away by exporting the \RPython sources to C.
However, before the C export step, all the compile-time reflection statements are evaluated and flattened away.
This approach allows \RPython \VMs to behave almost like standard \Python programs while still providing excellent performance in the final \VM binary.

\paragraph{High-level Tracing \JIT}
Much like the automatic memory management, \PyPy provides a tracing \JIT generator \cite{Bolz09a}.
By default the \VM programmer does not write an explicit \JIT in \PyPy.
Instead the \VM code is annotated to guide the underlying tracing \JIT generator.
This means a \VM compilation time a specific tracing \JIT is created for the given meta information.
As a result, the \JIT can track high-level loops in the final interpreted language.


% ---------------------------------------------------------------------------
\subsection{Runtime Reified or Self-aware \VMs}
\seclabel{background-reified-vms}
% ---------------------------------------------------------------------------

The \VMs presented so far have little or no self-awareness.
Typically the \VM generation frameworks only allow a high amount of reflection at \VM compile time.
This meta information is typically compiled away, similar to a C++-based \VM.
The \VM frameworks themselves behave like a static language on their own.
The final \VM artifact has no access to the underlying definition anymore.
Typically some structural meta information is available at runtime but not made available to the language running on top.

We are now going to present \VMs that behave significantly different.
These \VMs have direct control over the underlying infrastructure and most concepts
\cb{yadda yadda yadda}
\todo{need proper link from static VM to dynamic VM}\\
\todo{draw parallel to C (classical VM), vs C++ (Maxine / Jikes), Java (PyPy) vs someting like ST} \\
\todo{probably add table for comparison}\\
\todo{Proper separation \cite{Wimm12a} at compile time should make it easy to push it to dynamic/runtime}

% ------------------------------------------------------------------------------
\subsubsection*{\Pinocchio \VM}
\seclabel{background-pinocchio}
\todo{reread + more problem oriented}

The \P \VM \cite{Verw11a} presented in \secref{background-pinocchio} is a direct predecessor of the work presented in this thesis.
The knowledge gained while participating on \P had a great influence on the development direction of \B and its applications.

Unlike \PH running on the \Cog \VM the \P research \VM has no bytecode interpreter.
The only execution base is native code which is directly generated by the language-side compiler.
At the current stage of development \P has not yet support for a separate image as in \PH.
The runtime image is currently defined by the bootstrap process where classes, objects and methods are exported into binary images and linked together with a primitive kernel to a final executable.

\paragraph{Going Native}
We took from \P that language-side native code generation is not more complex than generating bytecodes.
Instead we directly embrace the native world.
This means that in the core \P already uses many concepts that are only introduced by the \JIT in the \Cog \VM.
Hence, \P does no longer distinct between \JIT mode and interpreter mode.
Here the gain for \P are twofold: we could boost the performance of the language-runtime and simplify the design by not needing a dual compilation pipeline for the \JIT and the bytecode.

\paragraph{Going Meta}
Even so \P directly uses native code as core execution mode we avoided to directly write native code if possible.
For instance the method lookup in \Cog is statically implemented at \VM-side using \Slang.
We described in \secref{background-pinocchio} in detail how \P uses language-side code instead for the lookup.
Using the combination of low-level code to flatten out meta recursion we still have full language-side control over the lookup while maintaining good performance.

\paragraph{Missing Low-level Reification}
The most obvious shortcoming of \P was the lack of its own garbage collector.
Instead of investing time into a separate well-defined \GC \P relies on the conservative \urlfootnote{Boehm \GC}{http://www.hpl.hp.com/personal/Hans_Boehm/gc/} built for C programs.
The Boehm \GC is sufficiently fast to run \P as a prototype, however, due to its generic nature it is not as efficient as a specific \GC.
However, \P lacked the necessary reification at level of the object layout to properly implement a \GC.
All the notion about the object layout in memory are hard-coded in the compiler in several places.

\todo{no real distinction between \JIT and interpreter} \\
\todo{compiler directly generates native code} \\
\todo{simplified infrastructure} \\
\todo{lagnuage-side: lookup links back to language-side code with prefilled native code to avoid meta recursion}
\todo{missing reification for the layout (work in progress)} \\
\todo{missing reification for low-level \VM objects} \\
\todo{still used minimal C kernel for simplicity} \\
\todo{required gcc + linker for bootstrap}

% ------------------------------------------------------------------------------
\subsubsection*{\MIST a C-less \ST Implementation}
\urlfootnote{\MIST}{http://mist-project.org/} is another prototype \ST \VM that follows similar goals as the \P \VM.
It not longer uses bytecode interpreter but only relies on native code.
However, it goes one step further than \P by not relying on any C-based infrastructure.
\MIST implements its own linker to build the final executable.
And unlike \P it does not require kernel primitives written in C.
\MIST brings its own implementation to directly perform system calls from within the language.

% ------------------------------------------------------------------------------
\subsubsection*{\Klein \VM}
\seclabel{background-klein}
\todo{reread + more problem oriented}
\urlfootnote{\Klein}{http://kleinvm.sourceforge.net/} is a metacircular \VM for the \Self programming language that has no separation into \VM and language \cite{Unga05a}.
The \VM is entirely written in \Self but takes the concept of metacircular beyond the compile-time.
For instance, unlike many other metacircular \VMs, including \Cog and \Squeak, \Klein does not use an intermediate low-level language to bootstrap the system.
It generates directly a binary image, much like the aforementioned \P or \MIST \VM.
However, it is important to note that the \VM-level structures and objects are not compiled away as it is usually the case.
Instead the \VM structures are represented as real \Self objects.
Hence the \Klein \VM supports true \VM-level reflection since there is only a single code base.

Additionally to the advances in reflection and metacircularity, \Klein focuses on fast compilation turnarounds to allow for a responsive development process.
Which is unlike the \Squeak \VM where a full \VM bootstrap takes a order of minutes on modern hardware.
\Klein also supports advanced mirror-based debugging tools to inspect and modify a remote \VM.

Development on the \Klein \VM seized in 2009 and left the \Klein \VM in fairly usable state.
However, up to now it lacks a proper \GC which essentially limits its real-world application.
Yet, it proved that it is possible and build a language-runtime without a proper separation of the language-side and the \VM or base-level.
From the literature presented about the \Klein project we see a strong focus on the improvements of the development tools.
The fact that the language-runtime allows \VM-level reflection to change the \VM dynamically is not directly mentioned in the literature.
While we see the practical limitations of changing the \VM at runtime we would like to open the doors to this new form of reflection.
\todo{reread paper}
\todo{Image: Infrastructure Overview}


% ===========================================================================
\section{Problem 1: Dynamic High-level Low-level Programming}
% ===========================================================================
\todo{show limitations}
\todo{HL-LL programming only avaialble at compile time}
\todo{at runtime, partially in the \JIT}

% ===========================================================================
\section{Problem 2: Extended Intercession}
% ===========================================================================
\todo{show limitations}
\todo{Intercession, if available only to language-side}
\todo{very little possibility to alter the \VM from language-side}


% ===========================================================================
\section{Problem 3: Dynamic Changing \VM Components}
% ===========================================================================
\todo{show limitations}


% ===========================================================================
\section{Summary and Outlook}
% ===========================================================================

\todo{Intro + List again the problems} \\
\todo{Sync Chapter Outlook}\\
\todo{rewrite more problem oriented}
\begin{description}	
	\item[\chapref{reification}] focuses on language-side applications that simplify the interaction with the underlying \VM.
	We present a custom inspector framework that is now used by default in \PH.
	As a second part we explain how we introduced first-class layouts and slots to \PH to reify the low-level structural layout of objects.
	Both projects are crucial for metacircular \VM development and are direct results from the research conducted on the \P \VM.
	
	\item[\chapref{benzo}] describes a high-level low-level programming framework named \B.
	The core functionality of \B is to dynamically execute native-code generated at language-side.
	\B allows us to hoist typical \VM plugins to the language-side.
	Furthermore we show how code caching makes \B efficient and users essentially only pay a one-time overhead for generating the native code.
		
	\item[\chapref{ffi}] presents \NB, a stable foreign function interface (\FFI) implementation that is entirely written at language-side using \B.
	\NB is a real-world validation of \B as it combines both language-side flexibility with \VM-level performance.
	We show in detail how \NB outperforms other existing \FFI solutions on \PH.
	
	\item[\chapref{validation}] focuses on two further \B applications.
	In the first part we present \WF a framework for dynamically generating primitives at runtime.
	\WF extends the concept of metacircularity to the running language by reusing the same sources for dynamic primitives that were previously used to generate the static \VM artifact.
	In a first validation we show how \WF outperforms other reflective language-side solutions to instrument primitives.
		
	In a second part of \chapref{validation} we present \NBJ a prototype \JIT compiler that is based on \B.
	\NBJ shows the limitations of the \B approach as it required a customized \VM to communicate with the existing \JIT interface for native code.
	Our prototype implementation generates the same native code as the existing \VM-level \JIT, however, it is currently limited to simple expressions.
	\NBJ shows that for certain applications a well-define interface with the low-level components of the \VM is required.
	
	\item[\chapref{future}] summarizes the limitations of \B and its application, furthermore we list undergoing efforts on the \B infrastructure and future work.
\end{description}


% =============================================================================
\input{chapter-footer.tex}